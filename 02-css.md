Каскадні таблиці стилів
=====

Важливою складовою будь-якого сайту окрім вмісту є його зовнішній вигляд. Зовнішній вигляд сайту налаштовується за допомогою спеціальної мови стилів *CSS* (англ. Cascading Style Sheets – каскадні таблиці стилів). *CSS* визначає шрифти, колір елементів, відступи та поля, висоту та ширину елементів та інші параметри сторінки.

Основна ідея використання *CSS* – розділити зміст та логічну структуру документу (яка задається через *HTML*) та його відображення (задане через *CSS*). Й якщо в попередніх версіях (до 5-ї) *HTML* широко використовувався для налаштування оформлення сайтів: застосовувались теги такі як `<center>` для відцентрування елементів, `<font>` для визначення атрибутів шрифту, HTML-атрибути `width`, `height` та інші, то зараз вони вважаються застарілими й їх функції повністю перейшли до *CSS*. Задання дизайну сторінки за допомогою *CSS* надає набагато більше налаштувань зовнішнього вигляду, дозволяє використовувати вже створені стилі на інших сторінках та задавати різні стилі для різних засобів відображення (екран, друк, смартфон).

Структура *CSS*-команди наступна: спочатку йде селектор (`body`) – критерій, за яким будуть вибрані елементи до яких тре застосувати стиль. В данному випадку вибирається тільки тег `<body>` – тобто весь документ. Далі в фігурних дужках йдуть властивості (`background-color`) та їхні значення (`#FF0000`). Фактично такий код змінює колір фону всього документу. В html це можна було зробити так: `<body bgcolor="#FF0000">`.

Інсує декілька способів визначити стилі документу:

1. Визначити стилі документу можна в самому документі, за допомогою тегу `<style>`:

```html
        <style> body { background-color: #FF0000; } </style>
```

2. Стилі можна визначити inline в тезі документу:

```html
        <body style="background-color: #FF0000;">
```

3. Можна створити зовніщнє посилання на файл стилів:

```html
        <head>
            <link rel="stylesheet" type="text/css" href="style.css"/>
        </head>
```

    Це посилання вказує браузеру, що він повинен використовувати правила відображення HTML-файлу з CSS-файлу. Найважливіше тут те, що одночасно кілька HTML-документів можуть посилатися на одну таблицю стилів. Інакше кажучи, один CSS-файл можна використовувати для управління відображенням безлічі HTML-документів. Файлів стилів можна підключати скільки завгодно.

Селектори
-----
Щоб застосувати css-оформлення до HTML-елементу або безлічі елементів, зазвичай використовуються селектори – спеціальні правила, за якими відбираються HTML-об'єкти, до яких потрібно застосувати css-стиль.

Можливо застосовувати наступні типи селекторів:
`*`
: вибирає будь-який елемент, наприклад: `* { border: 1px solid #777; }` встановить рамку для всіх елементів в 1 піксель, кольору `#777777` (відтінок сірого)

`html селектор`
: `h1 { font: bold 10pt verdana; }` – всі теги `<h1>` матимуть жирний шрифт Вердана розміром 10 пунктів.

`.className`
: Вибирає елемент за класом. Клас – це певне ім'я, яке ми можемо застосувати до будь-яких HTML-тегів, щоб згодом посилатися на них. Ім’я може бути будь-яким. Зручність селекторів у тому, що можна встановити одне ім'я класу безлічі html-тегів у документі і потім змінювати зовнішній вигляд тільки цих елементів, звертаючись до них по імені класу. Наприклад вибір всіх елементів з класом `emphasize`:

```css
    .emphasize { font-weight: bold; }
```
В html для тегів клас задається наступним чином:  `<p class="emphasize">Виділений текст</p>`
    
Звичайно селектори можна поєднувати:  

```css    
   a.eco { color: green; background-color: yellow; }
```

Вибере тільки теги `<a class="eco">`.

Також можливо задавати декілька класів одному елементу, наприклад (*з фрейворку boostrap*) зручно задати такий клас:

```css
    .pull-right { float: right; }
```

А потім легко притягувати текст до правого краю примішуючи даний клас до потрібних елементів:  

```html        
    <p class="emphasize pull-right">Виділений текст</p>
```

`#id`
: за ідентифікатором. Ідентифікатор схожий до імені класу, за однією відмінністю, що ідентифікатор має бути унікальним на документ, та задається в html наступним чином: `<form id="login-form"></form>`. Для того щоб застосувати стилі до такого елементу можна скористатись селектором:

```css
    #login-form {margin:0; padding:0;}
```

або  

```css
    form#login-form {margin:0; padding:0;}
```

Властивість `margin` становлює величину відступу від кожного краю елемента. Відступом є простір від кордону поточного елемента до внутрішньої межі його батьківського елементу. А padding - встановлює значення полів навколо вмісту елемента. Полем називається відстань від внутрішнього краю рамки елемента до уявного прямокутника, що обмежує його вміст.

`div+h1`
: вибирає всі елементи `<h1>`, які йдуть одразу після елементів `<div>`

`h1~div`
: вибирає всі елементи `<div>`, які йдуть перед елементами `<h1>`

`#login-form>input`
: селектори потомків. Можливо також вибирати елементи через батьківський клас:

```css    
    #login-form>input { width: 90px; }
```

Встановить ширину всім дочірнім тегам `<input>` до тегу з ідентифікатором `login-form`.

`#login-form input`
: також селектор потомків, однак, працює у випадку якщо теги `<input>` не є беспосередніми потомками тегу `#login-form`.

`a:hover`
: селектори псевдокласів дозволяють задати стилі елементам в залежності від їх стану, наприклад наступний стиль задасть колір посилань під час наведення на них курсору:

```css
        a:hover {color:green;}
```

Чи, наприклад, стиль активних посилань: `a:active {color:red;}`.

Медіа типи
-----

При підключенні можна задавати медіа типи css-файлів чи блоків, що дозволяє використовувати різні стилі для різних пристроїв, наприклад окремий стиль для друкованої версії сторінки, який містить спрощену версію сайту без кольорового оформлення та з прихованими елементами меню.

```html
    <link rel="stylesheet" type="text/css" media="display" href="main.css">
    <link rel="stylesheet" type="text/css" media="print" href="print_main.css">
```

Такі правила можна також застосовувати в одному файлі використовуючи media queries (медіа запити):

```css
    @media screen {
        body { font-size: 13px; }
    }
    @media print {
        body { font-size: 10pt; }
        #menu { display:none; }
    }
    @media screen, print {
        body { line-height: 1.2 }
    }
```

Медіа запити дозволяють також підлаштовувати сайт під різні екрани, що особливо критично для смартфонів та планшетів:

```css
    @media only screen
        and (min-width : 1224px)
    {
        body { line-height: 1.2 }
    }
```

Основні *CSS* властивості
-----

`margin`
: це зовнішній простір між рамкою і невидимою границею прямокутника. Це скорочена властивість для: `margin-top`, `margin-right`, `margin-bottom` і `margin-left`.

`padding`
: це внутрішній простір між вмістом елементу й його рамкою. Теж скорочена властивість. Приклад:

```css    
    p {padding: 2em auto}`
```

Надасть відступ у 2 масшатабовані одиниці зверху й зліва, та автоматично порахувати відступ знизу й справа. При одному значенні – границі будуть однакові. Якщо вказати 3 значення то стиль приміниться до верхньої, правої та лівої та нижньої границь. Якщо вказати 4 значення – границі будуть проставлені за часовою стрілкою: верхня, права, нижня, ліва.  

`border`
: керує зовнішнім виглядом рамки (бордюру) навколо елемента, дозволяючи визначити в одному рядку відразу кілька атрибутів: колір, стиль і ширину. По суті, `border` пропонує швидкий варіант вказівки властивостей `border-width`, `border-style` та `border-color`. Приклад:

```css
    p {border: 3px dotted red}
```

`color`
: змінює колір елементу. Колір зазвичай задається у форматі RGB: у вигляді 3-х шіснадцядкових чисел після `#` по два знаки на кожне. 

```css    
    div { color: #AA00FF; }
```

`background-color`
: змінює колір фону елементу.

`background-image`
: задає фонове зображення елементу

```css
    table td.marked { background-image: url('paper.png'); } 
```

`font-family`
: дозволяє вибрати шрифт для відображення тексту. Якщо вказати кілька шрифтів через кому – браузер використає перший наявний на комп'ютері користувача. Якщо в імені шрифту є пробіли, його потрібно укласти в подвійні або одинарні лапки.

```css
    p {font-family: Courier, "Courier New", monospace;}
```

На той випадок, коли жоден з перерахованих у списку шрифтів у клієнта не встановлений, рекомендується в кінці списку додавати ім'я сімейства шрифтів, наприклад: `serif`, `sans-serif`, `monospace`, `fantasy` або `cursive`.

`font-size`
: дозволяє задати розмір шрифту. Доброю практикою вважається вказувати відносні розміри шрифту у відсотках або `em`. Можна застосовувати відносні розміри: `larger` та `smaller`, або ж іменовані `xx-small`, `x-small`, `small`, `medium`, `large`, `x-large` или `xx-large`. 

```css
    p {font-size: 1em}
    h1 {font-size: 180%}
    h2 {font-size: 140%}
    .copyright {font-size: x-small}
```

Можна задавати точний розмір в пунктах `pt` (1/72 дюйма), в піках – `pc` (12pt) ну або ж в більш звичних одиницях – пікселях `px`, дюймах `in`, сантиметрах `cm` чи міліметрах `mm` – хоча використання абсолютних одиниць не вітається, оскільки може призвести до проблем з версткою на моніторах з різним dpi. Також є відносні міри до шрифту: `em` – ширина літери M в поточному шрифті – дозволяє масштабувати розміри шрифту відносно загального шрифту в документі, наприклад, якщо в документі заданий шрифт `12pt`, то `0.5em` для елемента зробить шрифт у нього в 2 рази менший, `ex` – аналогічно, але літери X.

`display`
: визначає як елемент буде відображено (або приховано в документі). Найбільш вживані значення наступні:
        `inline` - елемент розміщатиметься всередині тексту, наприклад тег `<p>` автоматично переносить вміст на нову стрічку, дане значення дозволяє відмінити поведінку.
        `none` - приховає елемент з документу
        `block` - (зворотнє до `inline`) відображатиме елемент у вигляді блоку з переносом стрічки до та після нього.

`float`
: дозволяє закріпити елемент до лівого або правого краю сторінки, а інші елементи почнуть обтікати даний.
Значення:
  right – елемент липне до правого краю, а наступні обтікають його зліва.
  left eлемент липне до лівого краю, а наступні обтікають його справа.
  none елемент не липне, а розташовується в звичайному режимі. Наступні елементи не обтікають його, а розташовуються в звичайному порядку. (значення за замовчуванням)

Наприклад, якщо задати стиль:

```css
    div.list {
        float: left;
        margin-right: 5px;
        width: 90px;
    }
```

Тоді наступні елементи `div` при наявності простору місця будуть розташовані в горизонтальній площині, замість вертикальної. Якщо ширини браузера не вистачатиме – другий `div` буде перенесено вниз:

```html
    <div class="list">El1</div>
    <div>El2</div>
```

З версткою щоденно зтикаються тисячі людей, тому звичайно вже створено багато *СSS* бібліотек та фреймворки, які допомагають розробникам створити адаптивний сайт, який крім достойного вигляду однаково добре відображатиметься на різних пристроях. Серед таких фреймворків варто звернути увагу на бібліотеку [*Boostrap*](http://getbootstrap.com), й якщо не скористатись нею, то, принаймні,проглянути як реалізовані ті чи інші елементи керування. Для неї також існує набір готових до використання частин сайту з вихідними кодами: [*Bootsnipp*](http://bootsnipp.com), та різні теми: [*Bootswatch*](https://bootswatch.com). Також достойними уваги є [*Foundation*](http://foundation.zurb.com) від компанії *Zurb* та [*Material Design*](http://www.getmdl.io) від *Google*.
