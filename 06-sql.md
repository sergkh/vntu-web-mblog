SQL
-----------

Важливою частиною веб додатків є інформація, яку вони надають своїм користувачам. Унікальність й способи подачі інформації часто визначають популярність того чи іншого ресурсу. Й відповідно більшість сучасних веб додатків обробляють значні обсяги даних. Важливо розсудливо підійти до вибору способу зберігання даних додатку, тому найчастіше для цього використовуються системи керування базами даних СКБД. Серед популярних реляційних СКБД є *MySQL*, *PostgreSQL*, *Oracle*, *MS SQL*.  

Реляційні СКБД дозволяють обробляти великі обсяги даних (мільйони записів) й мають стандартизовану мову для роботи з даними за допомогою спеціальної мови — *SQL*. 

*SQL* (англ. Structured query language — мова структурованих запитів) – це декларативна мова для взаємодії користувача з базами даних (БД), що застосовується для формування запитів, оновлення та керування реляційними БД, створення схеми БД та її модифікації, системи контролю за доступом до даних. 

Перша версія мови *SQL* була розроблена на початку 1970-х років корпорацією *IBM*. Ця версія носила назву *SEQUEL* і була призначена для обробки та пошуку даних, що містилися в реляційній базі даних *IBM*, *System R*. Мова *SQL* пізніше була стандартизована Американськими Держстандартами (*ANSI*) в 1986. Наразі вона є стандартом де-факто для переважної більшості реляційних СКБД.

Сама по собі *SQL* не є мовою програмування, як *C* або *Pascal*, а лише дозволяє формувати інтерактивні запити або виступати в якості інструкцій для керування даними при роботі з СКБД. Стандарт *SQL*, крім того, вміщує функції для визначення зміни, перевірки і захисту даних. Тому мову поділяють на наступні частини, які відрізняються за своїм призначенням:

1. *DDL* (Data Definition Language) — робота із структурою бази,
2. *DML* (Data Manipulation Language) — робота із стрічками,
3. *DCL* (Data Control Language) — робота з правами,
4. *TCL* (Transaction Control Language) — робота з транзакціями.

Розглянемо окремо кожну з частин більш детально. 

>Синтаксис *SQL*, так само як і типи полів, іноді дещо відрізняються для різних СКБД, тому бажано звірятись з документацією перед написанням запитів. В даному випадку розглядатиметься синтаксис, який може використовуватись в СКБД *PostreSQL* чи *H2DB*.

Мова опису даних
------

Data Definition Language (DDL – мова опису даних) — це частина мови *SQL*, що використовуються в СКБД для опису структури даних. Більшість *DDL* запитів починаються з дієслів:

`Create` — Створити
`Alter` — Змінити 
`Drop` — Видалити

Наприклад розглянемо запит:
```sql
    CREATE TABLE students(
      id bigserial PRIMARY KEY,
      created timestamp NOT NULL DEFAULT NOW(),
      email varchar(512) NOT NULL,
      name varchar(128) NOT NULL,
      students_group varchar(10) NOT NULL,
      mark integer,
      UNIQUE(email)
    );
```
Даний запит створить табличку `students` для зберіння даних про студентів з вказаними шістьма полями й зробить поле `email` унікальним. Регістр для ключових слів не має значення, для назв таблиць та колонок — зазвичай також, однак залежить від налаштувань СКБД. Розглянемо детальніше поля створюваної таблиці та їх типи:

`id`
: має тип `bigserial`, що є аналогічним до типу `bigint`, який в більшості СКБД приблизно відповідає розмірності типу `long` в *Java*, однак  `bigserial` додатково вказує СКБД автоматично збільшувати значення `id` при кожній вставці до даної таблиці. Можливо також задати тип `serial`, розмірність якого відповідає типу `integer` в СКБД або `int` в *Java*. Допис `PRIMARY KEY` вказує, що дане значення буде первичним ключем в даній таблиці.

`created`
: зберігатиме дату створення запису про студента. Тип `timestamp` дозволяє зберігати дату та час, відповідає `java.sql.Timestamp` з *Java* або `java.util.Date`. `NOT NULL DEFAULT NOW()` вказує, що в поле не можна записувати пусте значення `NULL`, однак якщо не вказувати жодного значення при створенні запису за замовчуванням запишеться результат виклику функції `NOW()`, яка повертає поточний час та дату.

`email`
: поле зберігатиме поштову адресу студента, є текстовим та відповідає типу `String` з *Java* однак має обмеження на кількість символів — до 512. `UNIQUE(email)` вказує що поле email – має бути унікальним для всіх записів.

`name`
: зберігатиме ПІБ студента й обмежено 128 символами.

`students_group`
: зберігатиме назву групи, в якій навчається студент. Максимум 10 символів. 

`mark`
: поле для збереження середнього балу студента. Може приймати значення `NULL` якщо ще не пораховано.

Для того щоб змінити створену таблицю, можна використовувується команда `ALTER`. Наприклад змінимо тип колонки `mark` на `real` – число з плаваючою комою, оскільки середній бал швидше за все не буде цілим числом:
```sql
    ALTER TABLE students
      ALTER COLUMN mark TYPE real;
```

Мова маніпуляції даними
-----

Тепер вставимо даних до нашої створеної таблички, для чого використовується  DML (Data Manipulation Language), який має такі основні дієслова:

`INSERT` — вставка запису;  
`SELECT` — вибірка;  
`UPDATE` — зміна;  
`DELETE` — видалення.  

Вставка стрічки в нашу таблицю буде мати вигляд:
```sql
    INSERT INTO students(email, name, students_group) VALUES ('ssv@gmail.com', 'Сковорода С. В.', '1KI-00');
    INSERT INTO students(email, name, students_group) VALUES ('pki@gmail.com', 'Пустоцвіт К. І.', '1KI-00');
    INSERT INTO students(email, name, students_group) VALUES ('nvd@gmail.com', 'Непейдиполе В. Д.', '1KI-00');
    INSERT INTO students(email, name, students_group) VALUES ('knv@gmail.com', 'Коломієць Н. В.', '2KI-00');
    INSERT INTO students(email, name, students_group) VALUES ('zis@gmail.com', 'Загребельний І.С.', '2KI-00');
```

Для того щоб вибрати всі дані з таблички скористаємось виразом:

```sql
    SELECT * FROM students
```

<table>
<thead>
<tr>
<td>id</td><td>created</td><td>email</td><td>name</td><td>students_group</td><td>mark</td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td><td>2013-10-02 10:41:18.015993</td><td>'ssv@gmail.com'</td><td>'Сковорода С. В.'</td><td>'1KI-00'</td><td>(Null)</td>
</tr>
<tr>
<td>2</td><td>2013-10-02 10:41:18.015993</td><td>'pki@gmail.com'</td><td>'Пустоцвіт К. І.'</td><td>'1KI-00'</td><td>(Null)</td>
</tr>
<tr>
<td>3</td><td>2013-10-02 10:41:18.015993</td><td>'nvd@gmail.com'</td><td>'Непейдиполе В. Д.'</td><td>'1KI-00'</td><td>(Null)</td>
</tr>
<tr>
<td>4</td><td>2013-10-02 10:41:18.015993</td><td>'knv@gmail.com'</td><td>'Коломієць Н. В.'</td><td>'2KI-00'</td><td>(Null)</td>
</tr>
<tr>
<td>5</td><td>2013-10-02 10:41:18.015993</td><td>'zis@gmail.com'</td><td>'Загребельний І.С.'</td><td>'2KI-00'</td><td>(Null)</td>
</tbody>
</table>

Задання умов
----

TO BE DONE

Структура оператора SELECT:

```sql
    SELECT 
           [DISTINCT | DISTINCTROW | ALL]
           select_expression,...
       [FROM table_references]
         [WHERE where_definition]
         [GROUP BY {unsigned_integer | col_name | formula}]
         [HAVING where_definition]
         [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC], ...]
```

`WHERE` — використовується для визначення, які стрічки повинні бути вибрані чи включені до `GROUP BY`.
`GROUP BY` — використовується для групування стрічок з спільними значеннями. `HAVING` — визначає які стрічки після `GROUP BY` необхідно включити до вибірки.
`ORDER BY` — визначає за якими стовпцями необхідно відсортувати результати вибірки.

Агрегація даних
-------
TODO

Основні функції агрегації: COUNT, AVG, MIN, MAX, SUM

Оновлення
--------

TODO

```sql
UPDATE tablename SET <[column_name1 = value1 , column_name2 = value2, ...]> [WHERE <expression>];
```

Видалення
---------

```sql
    DELETE FROM table [WHERE <expression>];
```

Видалення це насправді рідко використовувана операція у веб додатках, по-перше видалення викликає фрагментацію файлу з даними – оскільки дані пишуться в файл підряд видалити дані з середини не є можливим, тому фізично дані залишаються, що знижує швидкодію всіх операцій. СКБД зазвичай буде періодично діагностувати табличку (операція `ANALYZE`) та видаляти такі видалені чи непотрібні після оновлення дані однак це зазвичай полягає у створенні нового файлу з даними й повним перенесенням всіх даних в нього (операція `VACUUM`) – що є досить затратним. По-друге, що навіть більш важливо, це те що на запис який видаляється можуть бути посилання в інших табличках, що змушує видаляти чи модифікувати й записи в інших табличках. 

Так, наприклад, в додатку веб-блог при видаленні користувача доведеться модифікувати чи видаляти й всі записи та коментарі користувача й можливо ті що відносяться до них. Тому зазвичай обмежуться прапорцем `boolean` полем `active`, `deleted` чи подібним, або наприклад полем `deleted_at` яке буде `Null` для активних користувачів чи містити час та дату видалення користувача.  


Індекси
------

Модель використання додатку, що працює з таблицею `students` швидше за все буде містити багато запитів за прізвищем студенту, наприклад:

```sql
    UPDATE students SET mark = 10 WHERE name = 'Сковорода С. В.'
```

При великих розмірах таблички (зазвичай порядок тисяч, але залежить від конфігурації ПК) запити такого плану будуть виконуватись достатньо довго, а при дуже великих розмірах (зазвичай порядок мільйонів) такі запити фактично взагалі "покладуть" СКБД. Тому що, при кожному такому запиті СКБД буде робити повне сканування таблиці (table scan) щоб знайти всі вказані записи (сервер не знає, що таке прізвище в табличці тільки одне, тому пройдеться по всіх). Для того щоб прискорити пошук необхідно створити індекс по даному полю, наступним чином:

```sql
    CREATE INDEX students_name_index ON students (name)
```

Індекс це зазвичай деревовидна (частіше збалансоване дерево b-tree – не путати з бінарним деревом) або Hash структура, що зазвичай зберігається в окремому файлі й забезпечує значне пришвидшення пошуку по даному полю (чи полям) та опціонально перевіряє унікальність поля, для чого треба додати ключове слово UNIQUE:

```sql
    CREATE UNIQUE INDEX students_name_index ON students (name)
```

Останній запис має аналогічний ефект як і задання унікальності поля при створенні таблиці. Primary key фактично теж неявно створює унікальний індекс. Індекс також можливо створювати по декільком полям одночасно:

```sql
    CREATE UNIQUE INDEX students_name_index ON students (name, email)
```

Однак чому ж тоді база даних не створює індекси автоматично для всіх полів таблиці? Тому що індекси мають також і негативний вплив: По-перше індекси займають додаткове місце на диску та в пам’яті, якщо індексів достатньо багато вони можуть потребувати навіть більше дискового простору ніж самі дані. По-друге три інших DML операції окрім вибірки будуть виконуватись довше — оскільки постійно потрібно буде крім даних оновлювати ще й індекс, а при унікальному індексу перед вставкою/оновленням перевіряти унікальність по індексу. Ну й останнє, якщо табличка достатньо мала (зазвичай порядок кількох тисяч) або залежно від специфіки запиту планувальник запитів СКБД може ігнорувати індекси, тому що іноді table scan виконуватиме запит швидше й ефекту від них не буде.

Для ілюстрації вищесказаного, наведено статистику по таблиці з реального проекту:

![](https://raw.githubusercontent.com/sergkh/vntu-web-mblog/lections/img/index_size.png)

Зведені таблиці
--------

Можна помітити деяку надмірність в нашій табличці `students`, а саме те, що поле група матиме в середньому близько 20 повторень (припустимо що в групі в середньому 20 чоловік). Тому необхідно провести нормалізацію цієї таблички.

Нормалізація схеми БД це процес розбиття одного відношення (таблиці) на декілька на базі функціональних залежностей, а нормальна форма — властивість відношення в реляційної моделі даних, що характеризує його з точки зору надмірності, яка потенційно може призвести до логічно помилкових результатів вибірки або зміни даних. Для цього необхідно ввести ще одну таблицю зі списком груп, а в таблиці students поле students_group замінити на ідентифікатор групи з нової таблиці.

```sql
    CREATE TABLE groups (
      id serial PRIMARY KEY,
      name varchar(512) NOT NULL
    );
```

Додамо нову колонку в базу:

```sql
    -- NOT NULL will fail for first time
    ALTER TABLE students ADD COLUMN group_id integer;
```

Вкажемо що таблички посилаються одна на одну:

```sql
    ALTER TABLE students ADD CONSTRAINT fk_students_group FOREIGN KEY (group_id) REFERENCES groups(id);
```

Перенесемо дані:

Створимо список груп:

```sql
    INSERT INTO groups (name) SELECT DISTINCT students_group FROM students;
```

Встановимо значення для ідентифікатору групи:
    
```sql
    UPDATE students SET group_id = (SELECT id FROM groups WHERE name = students_group);
```

Видалимо попередню колонку:

```sql
    ALTER TABLE students DROP COLUMN students_group;
```

Вибрати студента з групою:

```sql
    SELECT s.*, g.name as group FROM students s, groups g WHERE g.id = s.group_id
```

Або через JOIN:

```sql
    SELECT s.*, g.name as group FROM students s INNER JOIN groups g ON g.id = s.group_id
```

`Join` – операція з'єднання таблиць в SQL, яка об'єднує дві таблиці в реляційній базі даних, утворюючи нову тимчасову об’єднану таблицю.
В SQL існують такі типи об'єднання: внутрішнє – `INNER`, зовнішнє – `OUTER`. Зовнішнє об'єднання поділяють на ліве зовнішнє – `LEFT OUTER` та праве зовнішнє – `RIGHT OUTER`. В деяких випадках таблиці можна об'єднувати з собою, таке об'єднання зветься самооб'єднанням.

Data Control Language
-----

До мови контролю даних, відносять частину SQL, яка дозволяє керувати доступом до даних в базі. Детально ці команди розглянуто не буде, оскільки вони більше відносяться до адміністрування бази даних.

`GRANT` — надання прав користувачу;  
`DENY` — явна заборона для користувача;  
`REVOKE` — відміна заборони/дозволу користувачу.   

Transaction Control Language
-----------

`BEGIN TRANSACTION` — почати транзакцію;   
`COMMIT` — прийняти зміни прийняті в транзакції;  
`ROLLBACK` — відкат.

ACID (англ. Atomicity, Consistency, Isolation, Durability) – це набір властивостей, що гарантують надійну роботу транзакцій бази даних: атомарність, узгодженість, ізольованість, довговічність. Ці вимоги були сформульовані у 1970-х роках науковцем Джимом Греєм.

Атомарність (Atomicity)
: Атомарність гарантує, що жодна транзакція не буде виконана частково. Будуть або виконані всі операції, що беруть участь у транзакції або не виконано жодної. Якщо у процесі роботи однієї з операцій виникне помилка і операція буде відхилена, будуть відхилені також всі інші зміни, здійснені в межах транзакції.

Узгодженість (Consistency)
: Відповідно до цієї вимоги, система повинна знаходитись в узгодженому, несуперечливому стані до початку дії транзакції і по її завершенню. При цьому вона може знаходитись у неузгодженому стані у процесі виконання транзакції, проте ця неузгодженість завдяки іншим властивостям – атомарності та ізольованості – не буде видимою за межами транзакції.
Наприклад, при переведенні коштів з рахунка на рахунок, кошти можуть спочатку зніматись з першого рахунку, після чого нараховуватись на другий. Відповідно, після зняття коштів, але до їх нарахування система знаходиться в неузгодженому стані – коштів немає на жодному з рахунків. Але після завершення транзакції повна сума буде знаходитись на другому (або першому у випадку відміни транзакції) рахунку.

Ізольованість (Isolation)
: Ізольованість означає що ніякі проміжні зміни не будуть видимі за межами транзакції аж до її завершення. Питання ізоляції стає актуальним при одночасній роботі багатьох транзакцій з одними й тими ж даними. Згідно з цією вимогою, якщо у двох транзакціях буде спроба змінити одні й ті ж самі дані, одна із них буде відхилена, або ж призупинена до завершення другої.

Довговічність (Durability)
: Довговічність гарантує, що незалежно від інших проблем після відновлення роботоздатності системи результати завершених транзакцій будуть збережені. Іншими словами, якщо користувач отримав повідомлення про успішне завершення транзакції, то він може бути впевнений, що дані будуть збережені і відновлені у випадку збоїв.
