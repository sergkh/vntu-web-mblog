HTML-шаблони
---------
В даному розділі основну увагу буде приділено побудові *HTML* сторінок додатку на основі шаблонів, принципу функціонування шаблонів у фреймворку *Spring* та поясненням чому, власне, вони побудовані саме таким чином. 

Для початку необхідно визначитись з тим, що таке шаблони та шаблонізатори, які задачі вони вирішують на стороні сервера й які інші підходи можна використати для побудови сторінок. 

Шаблон — це файл або кілька файлів, написані на певній мові, які в подальшому наповнюються даними та перетворюються на веб сторінку (зазвичай це HTML-файл з різними маркерами, де необхідно вставити дані). А шаблонізатор, в свою чергу, це програмне забезпечення (найчастіше бібліотека), яке дозволяє на основі таких шаблонів та даних отримати на виході *HTML* сторінку. Шаблони є такими незаповненими бланками документів з деякими розширеними можливостями, які потім наповнюються даними.

Головною задачею використання шаблонів є розділення логіки, яка відповідає за бізнес процеси, та логіки відображення сайту. На перший погляд, самим простим підходом для побудови сторінки може здатись генерація *HTML* безпосередньо в коді програми, коли теги являються звичайними стрічками й розбавляються змінними отриманими з інших джерел. Розглянемо частину, коду яка має вивести останні записи блогу в табличному вигляді:

    ...
    BlogRecord[] records = recordsDao.getRecentRecords();
    out.println("<table>");
    
    for (BlogRecord b: records) {
        out.println("<tr>");
        out.println("<td>" + b.getTitle() + "</td><td>" + b.getAuthor().getName() + "</td><td>" + b.getTextPreview() + "</td>");
        out.println("</tr>");
    }
    out.println("</table>");
    ...

Одразу видно, що навіть такий спрощений код без форматування та стилів, результат якого буде малозрозумілим кінцевому користувачу вже виглядає досить запутаним. Підтримувати такий код теж приноситиме мало задоволення, а особливо тут варто врахувати той факт, що зазвичай відображенням займаються окремі люди — верстальщики, які не завжди є програмістами за фахом, й розібратись в чужому коді їм буде достатньо складно. 

Використовуючи шаблонізатор, код отримання записів блогу можна було б залишити в Java файлі, а *HTML* в шаблон, який виглядав би так:

    <table>
      <tr th:each="b: ${records}">
        <td th:text="${b.title}">Sample blog title</td>
        <td th:text="${b.author.name}">Sample author</td>
        <td th:text="${b.textPreview}">Preview...</td>
      </tr>
    </table>

Такий код є валідним *HTML* кодом, тому вигляд сайту можна переглянути в браузері й він більш зрозумілий для верстальщика.

Додатковою перевагою є те, що шаблони можна повторно використовувати — більшість шаблонізаторів надають можливості для включення одних шаблонів у інші. Так вищенаведене відображення списку записів блогу може зустрічатись на різних сторінках з різними даними, тому логічно його винести в окремий файл та перевикористати його для різних сторінок.

Використання шаблонів також надає гнучкості у відображенні даних — один й той  самий список записів блогів може бути представлений за домогою різних шаблонів, для того, щоб отримати зовсім інший вигляд цього списку.

До недоліків шаблонізаторів слід віднести: шаблонізатори зазвичай вимагають більше ресурсів та часу для генерації кінцевого результату, деякі шаблонізатори мають складну й не надто гнучку мову, яку необхідно додатково вивчати, писати безпосередньо код в шаблонах більшість шаблонізаторів не дозволяє.

# Thymeleaf #

В якості шаблонізатора за замовчуванням розробники бібліотеки *Spring* пропонують бібліотеку *Thymeleaf*. Звичайно можна підключити будь-яку іншу, однак цей варіант є досить продвинутим — шаблони є звичайними *HTML*/*XML* сторінками, які можна відобразити в браузері, а за допомогою спеціальних атрибутів можна зазначити в які теги необхідно вставити які дані.

Якщо розглянути приклад, наведений вище:

    <table>
      <tr th:each="b: ${records}">
        <td th:text="${b.title}">Sample blog title</td>
        <td th:text="${b.author.name}">Sample author</td>
        <td th:text="${b.textPreview}">Preview...</td>
      </tr>
    </table>

то можна побачити специфічні атрибути з префіксом `th`, по ним шаблонізатор взнає як відображати дану табличку, а саме `each` — каже йому, що тег `<tr>`, як і його вміст має бути повторено для всіх елементів списку чи масиву `records` (який формується з Java й передається ззовні в шаблон), при кожній ітерації поточний елемент масиву буде записано в змінну `b`. Атрибут `text` — каже що необхідно замінити текст тегу `<td>` – `Sample blog title` на відповідне значення атрибутів запису блогу, сам текст в тегах використовується для правильного відображення шаблону, якщо його просто відкрити в браузері. Для обрахунку атрибуту `${b.title}` викликається метод `b.getTitle()`, тобто ім’я методу це назва атрибуту з `get` на початку та з великої букви.

> Такий підхід з формуванням імен атрибутів об’єктів є загальноприйнятим для *Java*: якщо, наприклад, об’єкт має атрибут `String firstName` то, зазвичай, йому встановлюють модифікатор доступу `private` та створюють публічні методи `getFirstName()` та `setFirstName(String fistName)`. Більшість бібліотек на *Java* опираються на цей принцип найменування.

Знаючи лише наведених вище 2 теги можна спробувати інтегрувати *Thymeleaf* у створений раніше додаток, а саме модифікувати головну сторінку так, щоб на ній відображались повідомлення отримані з *Java*. В подальшому повідомлення отримуватимуться з бази даних, однак для початку можна просто створити масив з наперед визначеними повідомленнями.

Першим кроком необхідно створити об’єкт, який описуватиме один запис в блозі. Для цього з меню необхідно вибрати *File → New... → Class* та обрати назву класу — `Post`. Також бажано вказати окремий пакет для класів, що описуватимуть сутності додатку (в даному випадку — `models`):

// TODO: add image new class post

Оскільки клас описує пост, йому необхідні будуть такі властивості: автор посту, текст, дата його створення:

    package labs.models;
    import java.util.Date;

    public class Post {
        private String author;
        private String text;
        private Date createdAt;
    }

Тепер через меню *Source → Generate Getters and Setters...* можна згенерувати всі get та set методи автоматично. Аналогічно можна згенерувати конструктори з різними наборами параметрів: *Source → Generate Constructor using fields...*, однак необхідно обов’язково додати конструктор без параметрів, який знадобиться при роботі з СУБД.

Аналогічно необхідно створити ще один клас `PostsService` в пакеті `services`, який відповідатиме за отримання та зберігання списку постів. Для початку він зберігатиме дані в звичайному списку, який створюватиметься кожен раз при старті й знищуватиметься при закритті додатку:

    package labs.services;

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Date;
    import java.util.List;

    import org.springframework.stereotype.Service;

    import labs.models.Post;

    @Service
    public class PostsService {
        private static final List<Post> INITIAL_POSTS = Arrays.asList(
            new Post("Admin", "First post", new Date()),
            new Post("Tester", "Second post", new Date()),
            new Post("Admin", "Third post", new Date())
        ); 
        
        private List<Post> posts = new ArrayList<Post>(INITIAL_POSTS);
        
        public List<Post> getRecentPosts() {
            return posts;
        }
        
        public void addPost(Post p) {
            posts.add(p);
        }
    }


Змінна `posts` міститиме список наявних постів користувачів у додатку й буде ініціалізуватись з наперед визначеного списку з трьох постів. Метод `getRecentPosts()` повертає даний список постів, а метод `addPost()` дозволяє додати до списку новий. Тепер необхідно щоб даний список постів передавався до представлення (шаблону), для цього змінимо клас `IndexController` наступним чином:

    package labs;

    import labs.services.PostsService;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Controller;
    import org.springframework.ui.Model;
    import org.springframework.web.bind.annotation.RequestMapping;

    @Controller
    public class IndexController {
        
        @Autowired
        private PostsService postsService;
        
        @RequestMapping("/home")
        public String index(Model model) {
            model.addAttribute("posts", postsService.getRecentPosts());
            return "index";
        }
    }

Анотація `@Service` перед `PostsService` дозволяє бібліотеці *Spring* дізнатись, що даний клас є сервісом і створити його автоматично, при чому створити лише один раз, а потім використовувати його в інших класах просто створивши змінну цього класу з анотацією `@Autowired`, так як це відбувається в `IndexController`. Такий підхід називається впровадженням залежностей — *Dependency Injection*, він дозволяє нам просто створити лише один екземпляр класу `PostsService` й використати його в різних місцях. В аргументи функції `index()` додано об’єкт `model`, який *Spring* автоматично створить для нас і автоматично передасть всі об’єкти, які в нього будуть записані до представлення, в даному випадку буде передано списко постів під іменем `"posts"`. Тепер залишилось відобразити його на сайті, для чого можна використати теги `th:each` та `th:text`:

    <div class="container">
        <div class="row" th:each="post: ${posts}">
            <hr/>
            <strong class="pull-left primary-font" th:text="${post.author}">Логін</strong>
            <small class="pull-right text-muted">
               <span class="glyphicon glyphicon-time"></span> 
                <span th:text="${post.createdAt}">19:05 14.05.14</span>
            </small>
            <br/>
            <div class="text-justify" th:text="${post.text}">Текст повідомлення</div>
        </div>
    </div>

Для правильного відображення сайту, необхідно підключити СSS-бібліотеку — *Bootstrap*. Результат роботи буде таким:

TODO: add posts-list

Щоб покращити вигляд сторінки дещо змінимо формат виведення дати замінивши `${post.createdAt}` на `${#dates.format(post.createdAt, 'HH:mm dd.MM.yy')}`.

Тепер можна також одразу додати можливість додавати пости, для чого в шаблон додамо простеньку форму:

    <div class="row">
        <form method="POST" action="/post">
            <div class="form-group">
                <label for="post-text">Що нового?</label>
                <textarea class="form-control" rows="3" name="text" id="post-text"></textarea>
            </div>
            <button type="submit" class="btn btn-success">Додати</button>
        </form>
    </div>

Форма відсилатиме текст, який користував ввів у параметрі `text` методом `POST`на URL: `/post`. Тепер необхідно написати обробник форми у класі `IndexController`, який додаватиме новий пост до списку існуючих:

    @RequestMapping(value = "/post", method = RequestMethod.POST)
    public String createPost(@RequestParam("text") String postText) {
        postsService.addPost(new Post("Unknown", postText, new Date()));
        return "redirect:home";
    }

В анотації `@RequestMapping` зазначається що даний метод обробляє тільки `POST` запити на URL `/post`. В *Spring* дані форми передаються як аргументи функції помічені анотацією `@RequestParam`, яка й пов’язує ім’я параметра форми `text` зі змінною. При чому *Spring* сам вміє перетворювати типи — якби необхідно було обробити булевий чи числовий параметр, то все, що потребувалось би це тільки змінити тип змінної на `boolean` чи `int` (або ж `Boolean` чи `Integer` якщо допускається також значення `null`). Метод створює новий об’єкт `Post` на основі введених даних (отримання імені користувача буде реалізовано після реєстрації) з поточною датою й часом. Після чого на браузер користувача відправляється команда Redirect на URL `/home` для чого замість імені шаблону повертається `"redirect:home"`. Виглядатиме сайт після цього наступним чином:

//TODO: add post-add.png

Отримані вихідні коди можна знайти за посиланням: TODO: add git commit URL







