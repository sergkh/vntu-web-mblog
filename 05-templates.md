HTML-шаблони
======

В даному розділі основну увагу буде приділено побудові *HTML* сторінок додатку на основі шаблонів, принципу функціонування шаблонів у фреймворку *Spring* та поясненням чому, власне, вони побудовані саме таким чином. 

Для початку необхідно визначитись з тим, що таке шаблони та шаблонізатори, які задачі вони вирішують на стороні сервера й які інші підходи можна використати для побудови сторінок. 

Шаблон — це файл або кілька файлів, написані на певній мові, які в подальшому наповнюються даними та перетворюються на веб сторінку (зазвичай це HTML-файл з різними маркерами, де необхідно вставити дані). А шаблонізатор, в свою чергу, це програмне забезпечення (найчастіше бібліотека), яке дозволяє на основі таких шаблонів та даних отримати на виході *HTML* сторінку. Шаблони є такими незаповненими бланками документів з деякими розширеними можливостями, які потім наповнюються даними.

Головною задачею використання шаблонів є розділення логіки, яка відповідає за бізнес процеси, та логіки відображення сайту. На перший погляд, самим простим підходом для побудови сторінки може здатись генерація *HTML* безпосередньо в коді програми, коли теги являються звичайними стрічками й розбавляються змінними отриманими з інших джерел. Розглянемо частину, коду яка має вивести останні записи блогу в табличному вигляді:

```java
    ...
    BlogRecord[] records = recordsDao.getRecentRecords();
    out.println("<table>");
    
    for (BlogRecord b: records) {
        out.println("<tr>");
        out.println("<td>" + b.getTitle() + "</td><td>" + b.getAuthor().getName() + "</td><td>" + b.getTextPreview() + "</td>");
        out.println("</tr>");
    }
    out.println("</table>");
    ...
```

Одразу видно, що навіть такий спрощений код без форматування та стилів, результат якого буде малозрозумілим кінцевому користувачу вже виглядає досить запутаним. Підтримувати такий код теж приноситиме мало задоволення, а особливо тут варто врахувати той факт, що зазвичай відображенням займаються окремі люди — верстальщики, які не завжди є програмістами за фахом, й розібратись в чужому коді їм буде достатньо складно. 

Використовуючи шаблонізатор, код отримання записів блогу можна було б залишити в Java файлі, а *HTML* в шаблон, який виглядав би так:

```html
    <table>
      <tr th:each="b: ${records}">
        <td th:text="${b.title}">Sample blog title</td>
        <td th:text="${b.author.name}">Sample author</td>
        <td th:text="${b.textPreview}">Preview...</td>
      </tr>
    </table>
```

Такий код є валідним *HTML* кодом, тому вигляд сайту можна переглянути в браузері й він більш зрозумілий для верстальщика.

Додатковою перевагою є те, що шаблони можна повторно використовувати — більшість шаблонізаторів надають можливості для включення одних шаблонів у інші. Так вищенаведене відображення списку записів блогу може зустрічатись на різних сторінках з різними даними, тому логічно його винести в окремий файл та перевикористати його для різних сторінок.

Використання шаблонів також надає гнучкості у відображенні даних — один й той  самий список записів блогів може бути представлений за домогою різних шаблонів, для того, щоб отримати зовсім інший вигляд цього списку.

До недоліків шаблонізаторів слід віднести: шаблонізатори зазвичай вимагають більше ресурсів та часу для генерації кінцевого результату, деякі шаблонізатори мають складну й не надто гнучку мову, яку необхідно додатково вивчати, писати безпосередньо код в шаблонах більшість шаблонізаторів не дозволяє.

Шаблонізатор Thymeleaf
-----

В якості шаблонізатора за замовчуванням розробники бібліотеки *Spring* пропонують бібліотеку *Thymeleaf*. Звичайно можна підключити будь-яку іншу, однак цей варіант є досить продвинутим — шаблони є звичайними *HTML*/*XML* сторінками, які можна відобразити в браузері, а за допомогою спеціальних атрибутів можна зазначити в які теги необхідно вставити які дані.

Якщо розглянути приклад, наведений вище:

```html
    <table>
      <tr th:each="b: ${records}">
        <td th:text="${b.title}">Sample blog title</td>
        <td th:text="${b.author.name}">Sample author</td>
        <td th:text="${b.textPreview}">Preview...</td>
      </tr>
    </table>
```

то можна побачити специфічні атрибути з префіксом `th`, по ним шаблонізатор взнає як відображати дану табличку, а саме `each` — каже йому, що тег `<tr>`, як і його вміст має бути повторено для всіх елементів списку чи масиву `records` (який формується з Java й передається ззовні в шаблон), при кожній ітерації поточний елемент масиву буде записано в змінну `b`. Атрибут `text` — каже що необхідно замінити текст тегу `<td>` – `Sample blog title` на відповідне значення атрибутів запису блогу, сам текст в тегах використовується для правильного відображення шаблону, якщо його просто відкрити в браузері. Для обрахунку атрибуту `${b.title}` викликається метод `b.getTitle()`, тобто ім’я методу це назва атрибуту з `get` на початку та з великої букви.

> Такий підхід з формуванням імен атрибутів об’єктів є загальноприйнятим для *Java*: якщо, наприклад, об’єкт має атрибут `String firstName` то, зазвичай, йому встановлюють модифікатор доступу `private` та створюють публічні методи `getFirstName()` та `setFirstName(String fistName)`. Більшість бібліотек на *Java* опираються на цей принцип найменування.

Знаючи лише наведених вище 2 теги можна спробувати інтегрувати *Thymeleaf* у створений раніше додаток, а саме модифікувати головну сторінку так, щоб на ній відображались повідомлення отримані з *Java*. В подальшому повідомлення отримуватимуться з бази даних, однак для початку можна просто створити масив з наперед визначеними повідомленнями.

Першим кроком необхідно створити об’єкт, який описуватиме один запис в блозі. Для цього з меню необхідно вибрати *File → New... → Class* та обрати назву класу — `Post`. Також бажано вказати окремий пакет для класів, що описуватимуть сутності додатку (в даному випадку — `models`):

![Майстер створення нового класу](https://github.com/sergkh/vntu-web-mblog/raw/lections/img/new-class-post.png)

Оскільки клас описує пост, йому необхідні будуть такі властивості: автор посту, текст, дата його створення:

```java
    package labs.models;
    import java.util.Date;

    public class Post {
        private String author;
        private String text;
        private Date createdAt;
    }
```

Тепер через меню *Source → Generate Getters and Setters...* можна згенерувати всі get та set методи автоматично. Аналогічно можна згенерувати конструктори з різними наборами параметрів: *Source → Generate Constructor using fields...*, однак необхідно обов’язково додати конструктор без параметрів, який знадобиться при роботі з СУБД.

Аналогічно необхідно створити ще один клас `PostsService` в пакеті `services`, який відповідатиме за отримання та зберігання списку постів. Для початку він зберігатиме дані в звичайному списку, який створюватиметься кожен раз при старті й знищуватиметься при закритті додатку:

```java
    package labs.services;

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Date;
    import java.util.List;

    import org.springframework.stereotype.Service;

    import labs.models.Post;

    @Service
    public class PostsService {
        private static final List<Post> INITIAL_POSTS = Arrays.asList(
            new Post("Admin", "First post", new Date()),
            new Post("Tester", "Second post", new Date()),
            new Post("Admin", "Third post", new Date())
        ); 
        
        private List<Post> posts = new ArrayList<Post>(INITIAL_POSTS);
        
        public List<Post> getRecentPosts() {
            return posts;
        }
        
        public void addPost(Post p) {
            posts.add(p);
        }
    }
```

Змінна `posts` міститиме список наявних постів користувачів у додатку й буде ініціалізуватись з наперед визначеного списку з трьох постів. Метод `getRecentPosts()` повертає даний список постів, а метод `addPost()` дозволяє додати до списку новий. Тепер необхідно щоб даний список постів передавався до представлення (шаблону), для цього змінимо клас `IndexController` наступним чином:

```java
    package labs;

    import labs.services.PostsService;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Controller;
    import org.springframework.ui.Model;
    import org.springframework.web.bind.annotation.RequestMapping;

    @Controller
    public class IndexController {
        
        @Autowired
        private PostsService postsService;
        
        @RequestMapping("/home")
        public String index(Model model) {
            model.addAttribute("posts", postsService.getRecentPosts());
            return "index";
        }
    }
```

Анотація `@Service` перед `PostsService` дозволяє бібліотеці *Spring* дізнатись, що даний клас є сервісом і створити його автоматично, при чому створити лише один раз, а потім використовувати його в інших класах просто створивши змінну цього класу з анотацією `@Autowired`, так як це відбувається в `IndexController`. Такий підхід називається впровадженням залежностей — *Dependency Injection*, він дозволяє нам просто створити лише один екземпляр класу `PostsService` й використати його в різних місцях. В аргументи функції `index()` додано об’єкт `model`, який *Spring* автоматично створить для нас і автоматично передасть всі об’єкти, які в нього будуть записані до представлення, в даному випадку буде передано списко постів під іменем `"posts"`. Тепер залишилось відобразити його на сайті, для чого можна використати теги `th:each` та `th:text`:

```html
    <div class="container">
        <div class="row" th:each="post: ${posts}">
            <hr/>
            <strong class="pull-left primary-font" th:text="${post.author}">Логін</strong>
            <small class="pull-right text-muted">
               <span class="glyphicon glyphicon-time"></span> 
                <span th:text="${post.createdAt}">19:05 14.05.14</span>
            </small>
            <br/>
            <div class="text-justify" th:text="${post.text}">Текст повідомлення</div>
        </div>
    </div>
```

Для правильного відображення сайту, необхідно підключити СSS-бібліотеку — *Bootstrap*. Результат роботи буде таким:

![Результат роботи програми](https://github.com/sergkh/vntu-web-mblog/raw/lections/img/posts-list.png)

Щоб покращити вигляд сторінки дещо змінимо формат виведення дати замінивши `${post.createdAt}` на `${#dates.format(post.createdAt, 'HH:mm dd.MM.yy')}`.

Тепер можна також одразу додати можливість додавати пости, для чого в шаблон додамо простеньку форму:

```html
    <div class="row">
        <form method="POST" action="/post">
            <div class="form-group">
                <label for="post-text">Що нового?</label>
                <textarea class="form-control" rows="3" name="text" id="post-text"></textarea>
            </div>
            <button type="submit" class="btn btn-success">Додати</button>
        </form>
    </div>
```

Форма відсилатиме текст, який користував ввів у параметрі `text` методом `POST`на URL: `/post`. Тепер необхідно написати обробник форми у класі `IndexController`, який додаватиме новий пост до списку існуючих:

```java
    @RequestMapping(value = "/post", method = RequestMethod.POST)
    public String createPost(@RequestParam("text") String postText) {
        postsService.addPost(new Post("Unknown", postText, new Date()));
        return "redirect:home";
    }
```

В анотації `@RequestMapping` зазначається що даний метод обробляє тільки `POST` запити на URL `/post`. В *Spring* дані форми передаються як аргументи функції помічені анотацією `@RequestParam`, яка й пов’язує ім’я параметра форми `text` зі змінною. При чому *Spring* сам вміє перетворювати типи — якби необхідно було обробити булевий чи числовий параметр, то все, що потребувалось би це тільки змінити тип змінної на `boolean` чи `int` (або ж `Boolean` чи `Integer` якщо допускається також значення `null`). Метод створює новий об’єкт `Post` на основі введених даних (отримання імені користувача буде реалізовано після реєстрації) з поточною датою й часом. Після чого на браузер користувача відправляється команда Redirect на URL `/home` для чого замість імені шаблону повертається `"redirect:home"`. Виглядатиме сайт після цього наступним чином:

![Результат роботи програми](https://github.com/sergkh/vntu-web-mblog/raw/lections/img/post-add.png)

Отримані вихідні коди можна знайти за [посиланням](https://github.com/sergkh/vntu-web-mblog/tree/87b913ccb0c5f09e93790abad0f9522773f857ec).

Варіанти отримання параметрів в контроллері
-----

Можна розглянути інші варіанти, як можна отримати параметри форми чи URL в контролерах *Spring*. Для початку, якщо параметрів форми досить багато, може виявитись незручним передавати їх усі в параметрах функції контроллера, в такому випадку можна створити окремий об’єкт, наприклад `PostForm` з усіма полями й передавати його. Такий варіант також дозволяє додати перевірку до полів форми на правильність введених даних:

```java
    import javax.validation.constraints.*;

    public class PostForm {

    @Size(min = 2, max = 120)
    private String title;

    @Size(min = 2, max = 1024)
    private String text;

    @NotNull
    @Min(1)
    private Integer order;

    get/set методи
}
```

Анотації обмежують розмір тексту в полях `title` та `text`, встановлюють мінімальне значення для поля `order` та вказують, що воно не може бути null, тобто є обов’язковим. Назви змінних повинні відповідати назві полів (атрибут `name`) у *HTML* формі. Обробка такої форми виглядатиме так:

```java
    ...
    @RequestMapping(value="/", method=RequestMethod.POST)
    public String createPost(@Valid PostForm person, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) { 
            return "form"; // якщо форма має помилки — відобразити форму
        }
        ...
        return "redirect:home";
    }
```

В даному випадку не розглядається відображення помилок користувачу, однак приклад з відображенням повідомлень на формі можна знайти в (офіційній документації)[http://spring.io/guides/gs/validating-form-input/].

Також може знадобитись отримати параметр безпосередньо як частину URL, наприклад, досить зручно коли окремий пост в блозі має URL виду: `/posts/spring-howto`, де `spring-howto` - унікальна назва посту. Або відображати профіль користувача за URL виду: `/users/userLoginName` Реалізовується він досить просто за допомогою анотації `@PathVariable`:

```java
    @RequestMapping(value="/posts/{postTitle}", method=RequestMethod.GET)
    public String getOrder(@PathVariable String postTitle) {
        отримання посту за назвою.
    }
```

При цьому зазвичай користувачу пропонують ввести окрім звичайної назви посту, додатково назву, яка відображатиметься в URL, або ж транслітерують назву автоматично.

Також іноді необхідно отримати доступ до *HTTP* заголовків, наприклад щоб вести статистику типів браузерів, якими користувачі заходять на сайт. Для цього можна додати параметр з анотацією `@RequestHeader`:

```java
@RequestMapping("/home")
public void home(@RequestHeader("User-Agent") String userAgent, Model model) {
    ...
}
```

Можна також отримати всі заголовки через змінну: `@RequestHeader HttpHeaders headers`.

Теги *Thymeleaf*
-----

Виведення неекранованого тексту. За замовчуванням при виведенні тексту за допомогою тегу `th:text` бібліотека екранує всі *HTML* символи, й якщо користувач введе, наприклад текст

```html
  <h1>Тест</h1>
```
то всі теги будуть екрановані й у документ буде вставлено:

```html    
    &lt;h1&gt;Текст&lt;/h1&gt;
```

При цьому браузер відобразить такий текст у тому ж вигляді, в якому він був введений. Виводити неекранований текст небезпечно, оскільки тоді зловмисники в кращому випадку може зламати верстку сайту, а в гіршому викрасти паролі інших користувачів. Проте за необхідності відобразити *HTML* у документі можна скористатись тегом `th:utext`, який не екранує теги.

Тернарний умовний оператор працює аналогічно як і в більшості мов програмування й має вигляд `умова ? значення якщо умова виконуєть : значення якщо ні`. Наприклад, для пустих постів можна виводити окремо напис:

```html
<div class="text-justify" th:text="${post.text.isEmpty()} ? '[Пусте повідомлення]' : ${post.text}">Текст повідомлення</div>
```

В якості умови можна використовувати звичайні оператори порівняння аналогічні тих в *C* та *Java*, єдине що знаки `<`, `>` мають бути замінені на екрановані версії `&lt;` та `&gt;`.

Можна також опціонально приховувати цілі блоки *HTML* сторінки в залежності від виконання умови. Наприклад на створеному сайті варто додати текст у випадку, якщо жодного посту ще не було створено:

```html
<div th:if="${posts.isEmpty()}">Постів немає</div>
```

Також окрім тексту програмно можна змінювати й атрибути тегів. Розглянемо тільки основні з них:

Атрибут `class`:

```html
<tr th:class="${row.even}? 'even' : 'odd'">
  ...
</tr>
```

URL зображення:

```html
<img th:src="@{author.avatarUrl}" scr="/placeholder.png" />
```

Значення полів введення форми:

```html
<input type="text" name="userName" value="John" th:value="${user.name}" />
```

Можна також отримувати дані з параметрів сторінки (якщо це GET параметри), наприклад якщо URL сторінки виглядає: `page.html?query=Test` отримати параметр `query` можна так:

```html
<p th:text="${param.query[0]}" th:unless="${param.query == null}">Placeholder</p>
```

Параметр завжди буде представлений як `String[]`, навіть якщо значення тільки одне. Другий атрибут `th:unless` ховає елемент якщо параметра `query` в URL немає.

Даний шаблонізатор має ще багато можливостей про які можна почитати в [офіційній документації](http://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html).


