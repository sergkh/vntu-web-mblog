HTML-шаблони
---------
В даному розділі основну увагу буде приділено побудові *HTML* сторінок додатку на основі шаблонів, принципу функціонування шаблонів у фреймворку *Spring* та поясненням чому, власне, вони побудовані саме таким чином. 

Для початку необхідно визначитись з тим, що таке шаблони та шаблонізатори, які задачі вони вирішують на стороні сервера й які інші підходи можна використати для побудови сторінок. 

Шаблон — це файл або кілька файлів, написані на певній мові, які в подальшому наповнюються даними та перетворюються на веб сторінку. А шаблонізатор, в свою чергу, це програмне забезпечення (найчастіше бібліотека), яке дозволяє на основі таких шаблонів та даних отримати на виході *HTML* сторінку. Шаблони є такими незаповненими бланками документів з деякими розширеними можливостями, які потім наповнюються даними.

Головною задачею використання шаблонів є розділення логіки, яка відповідає за бізнес процеси, та логіки відображення сайту. На перший погляд, самим простим підходом для побудови сторінки може здатись генерація *HTML* безпосередньо в коді програми, коли теги являються звичайними стрічками й розбавляються змінними отриманими з інших джерел. Розглянемо частину, коду яка має вивести останні записи блогу в табличному вигляді:

    ...
    BlogRecord[] records = recordsDao.getRecentRecords();
    out.println("<table>");
    
    for (BlogRecord b: records) {
        out.println("<tr>");
        out.println("<td>" + b.getTitle() + "</td><td>" + b.getAuthor().getName() + "</td><td>" + b.getTextPreview() + "</td>");
        out.println("</tr>");
    }
    out.println("</table>");
    ...

Одразу видно, що навіть такий спрощений код без форматування та стилів, результат якого буде малозрозумілим кінцевому користувачу вже виглядає досить запутаним. Підтримувати такий код теж приноситиме мало задоволення, а особливо тут варто врахувати той факт, що зазвичай відображенням займаються окремі люди — верстальщики, які не завжди є програмістами за фахом, й розібратись в чужому коді їм буде достатньо складно. 

Використовуючи шаблонізатор, код отримання записів блогу можна було б залишити в Java файлі, а *HTML* в шаблон, який виглядав би так:

    <table>
      <tr th:each="b: ${records}">
        <td th:text="${b.title}">Sample blog title</td>
        <td th:text="${b.author.name}">Sample author</td>
        <td th:text="${b.textPreview}">Preview...</td>
      </tr>
    </table>

Такий код є валідним *HTML* кодом, тому вигляд сайту можна переглянути в браузері й він більш зрозумілий для верстальщика.

Додатковою перевагою є те, що шаблони можна повторно використовувати — більшість шаблонізаторів надають можливості для включення одних шаблонів у інші. Так вищенаведене відображення списку записів блогу може зустрічатись на різних сторінках з різними даними, тому логічно його винести в окремий файл та перевикористати його для різних сторінок.

Використання шаблонів також надає гнучкості у відображенні даних — один й той  самий список записів блогів може бути представлений за домогою різних шаблонів, для того, щоб отримати зовсім інший вигляд цього списку.

# Thymeleaf #

В якості шаблонізатора за замовчуванням розробники бібліотеки *Spring* пропонують бібліотеку *Thymeleaf*. Звичайно можна підключити будь-яку іншу, однак цей варіант є досить продвинутим — шаблони є звичайними *HTML*/*XML* сторінками, які можна відобразити в браузері, а за допомогою спеціальних атрибутів можна зазначити в які теги необхідно вставити які дані.

Якщо розглянути приклад, наведений вище:

    <table>
      <tr th:each="b: ${records}">
        <td th:text="${b.title}">Sample blog title</td>
        <td th:text="${b.author.name}">Sample author</td>
        <td th:text="${b.textPreview}">Preview...</td>
      </tr>
    </table>

то можна побачити специфічні атрибути з префіксом `th`, по ним шаблонізатор взнає як відображати дану табличку, а саме `each` — каже йому, що тег `<tr>`, як і його вміст має бути повторено для всіх елементів списку чи масиву `records` (який формується з Java й передається ззовні в шаблон), при кожній ітерації поточний елемент масиву буде записано в змінну `b`. Атрибут `text` — каже що необхідно замінити текст тегу `<td>` – `Sample blog title` на відповідне значення атрибутів запису блогу, сам текст в тегах використовується для правильного відображення шаблону, якщо його просто відкрити в браузері. Для обрахунку атрибуту `${b.title}` викликається метод `b.getTitle()`, тобто ім’я методу це назва атрибуту з `get` на початку та з великої букви.



Однак перед тим як створювати шаблон необхідно розглянемо структуру створеного веб-додатку:

TO BE DONE: directory-structure.png

`src/main/java`
: в даній директорії містяться весь основний код програми на мові *Java*. Всі створені `*.java` файли містяться в пакеті `labs`.

`src/main/resources`
: дана директорія містить файл `application.properties` з основними налаштуваннями додатку, папку `static/` для зберігання статичних ресурсів додатку, а саме *CSS* та *Javascript* файли, а також папку `templates/` — де зберігатимуться *HTML*-шаблони, на основі яких будуть будуватись сторінки веб-додатку.

`src/test/java`
: директорія розрахована на так звані Unit-тести — невеликі підпрограми, які перевіряють правильність роботи окремих компонентів системи та взаємодії цих компонентів. Зазвичай для написання тестів використовують популярні бібліотеки такі, як *JUnit*, *TestNG* та інші. Використовуватись не буде.

`pom.xml`
: даний файл є конфігурацією консольної утиліти *Maven*, яка може використовуватись для автоматизованої компіляції, тестування та зборки проекту. Результати роботи *Maven* будуть поміщатись в діректорію `target/`.

