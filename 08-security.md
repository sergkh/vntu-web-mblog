Можливі методи відслідковування користувача:
------

Те що протокол HTTP не зберігає стану між запитами є перевагою (серверу не потрібно відслідковувати стан, тому він може потребувати менше ресурсів) й одночасно недоліком, тому що залишається відкритою проблема ідентифікації користувача. Тобто потрібен механізм, який допоміг би зв’язати кілька запитів й сказати що вони відносять до однієї сессії роботи користувача. Наприклад в інтернет магазині потрібно знати що запит замовлення товару відправив той самий користувач, який 5 хвилин назад додав мікрохвильову піч у корзину, а не інший. 

> Варіант просто завести відповідну змінну "корзина", наприклад, в сервлеті буде прекрасно працювати під час розробки - оскільки тільки ви як розробник будете замовляти товари. Однак як тільки користувачів стане більше, оскільки вони працюватимуть паралельно, можливі різні варіанти, коли один користувач буде замовляти товари іншого і перетирати чужі замовлення. Тому такий підхід краще відкинути одразу.

Перше що спадає на думку - визначати користувача по IP адресі, однак відношення між користувачем та IP не є одним до одного - можливий варіант коли декілька користувачів (або навіть достатньо багато) може працювати під однією IP адресою - коли вони знаходяться за NAT, або ж навпаки один користувач може мати динамічну IP адресу, яка буде змінюватись при переприєднанні його до мережі. Тому можна виділити такі підходи:

1. Додавати параметр - ідентифікатор сессії в кожен URL.
2. Додавати прихований параметр в кожну форму.
3. Зберігати дані в cookies.

При цьому ідентифікатор сессії має бути достатньо великим, тому що якщо взяти наприклад просто номер сессії чи користувача підряд:

	http://secure.somesite.com/userspage?sessionId=1567

зловмиснику досить просто підібрати ідентифікатор просто перебираючи варіанти підряд, або ж хитріше - отримавши ідентифікатор своєї сессії додати чи відняти від нього, наприклад, 1 - отримаєш сессію попереднього або наступного користувача. Тому ідентифікатором сессії має бути достатньо довгий та випадковий набір символів:

	http://secure.somesite.com/userspage?sessionId=903hfw74n6lMsEfyodG8r

Перший варіант має суттєвий недолік в тому, що ідентифікатор сессії користувача можна досить легко підглянути, а також що користувач може випадково передати свою сессію просто передавши URL на комусь із знайомих, тому зазвичай для цих цілей використовуються cookies і тільки якщо вони заборонені іноді прибігають до першого та другого варіантів.

Робота з cookies
------

Cookie - це фрагмент даних, який встановлюється веб-сервером і зберігається браузером на комп'ютері користувача. Браузер при доступі до сайту постійно пересилає цей фрагмент даних на сервер. Дозволяє зберігати дані між запитами на стороні користувача, й на практиці зазвичай використовується для:

1. аутентифікації користувача;
2. зберігання персональних переваг і налаштувань користувача;
3. відстеження 	сеансу користувача;
4. ведення статистики про користувачів.

Для того, щоб встановити Cookie сервер передає браузеру спеціальний заголовок HTTP пакету:

	Set-Cookie: name=value; expires=date; path=/; domain=.example.org.

Після чого браузер в кожному наступному запиті буде передавати отримані дані також у заголовку:

	Cookie: name=value

Враховуючи це необхідно намагатись мінімізувати розмір даних, що передаються у Cookie - оскільки це може значно збільшити трафік між клієнтом та сервером. 

Обов’язковими для cookie є пара name=value, однак розглянемо інші можливі атрибути:

	Set-Cookie: lang=ua; expires=Fri, 31 Dec 2013 10:59:59 GMT; path=/; domain=.mydomain.net; Secure; HttpOnly; 

`Expires`
: вказує час, після якого cookie буде автоматично видалено. Якщо цей атрибут не вказаний, то cookie зберігається до закриття браузера.

`Max-Age`
: другий варіант вказання часу життя cookie - час в секундах скільки буде дійсна cookie.

`Domain`
: визначає домен, для якого cookie є дійсним. Доступ до cookie завжди обмежений доменом з якого він був встановлений, що є основою безпеки для cookie, й якщо не вказати цього явно - буде використаний домен сайту який встановлював cookie. Явно вказувати домен необхідно, якщо потрібно дозволити доступ до cookie з піддоменів. Завжди починається з крапки.

`Path`
: визначає частину URL, для яких видима cookie.

`Secure`
: наказує передавати cookie тільки по безпечному з’єднанню, зазвичай https.

`HttpOnly`
: вказує, що значення cookie неможливо отримати з javascript через об’єкт document.cookie. Дозволяє додатково захистити cookie від крадіжки. 

`Version=1`
: - версія.

Програмно записати cookie можна так:

	Cookie cookie = new Cookie("user", "login");
	cookie.setHttpOnly(true);
	cookie.setMaxAge(20*60);

	response.addCookie(cookie);

Прочитати:

	Cookie[] cookies = request.getCookies();

Сессія користувача
------------

Сессії - це засіб, що суміщує в собі cookies (параметри в URL, якщо cookies заборонені) й зберігання даних на сервері для зберігання даних пов’язаних з сессією користувача.

Використання сесій в сервлетах досить проста і включає в себе отримання об’єкту сесії пов'язаної з поточним запитом, створення нового об'єкту сессії у разі потреби, зберігання та отримання інформації з сесії, та видалення сесій.

Для того щоб отримати, або створити сессію існує метод:

	HttpSession session = request.getSession(true);

В сессію можна занести будь-які дані:

	session.setAttribute("user", user);

а потім отримати їх:
	
	User user = (User) s.getAttribute("user");

При цьому дані зберігаються на сервері, а в cookie передається тільки ідентифікатор сессії, що є довільною випадковою стрічкою достатньо довгою, щоб її було важко підібрати шляхом перебору.

Зазвичай логіка роботи з сессіями така: після логіну (іноді після реєстрації також) для користувача створюється сессія й в неї заносяться будь-які дані користувача необхідні для подальшої роботи, наприклад логін чи ідентифікатор користувача, можливі права доступу. Далі в усіх сторінках шляхом перевірки сессії можна визначити чи користувач є залогіненим й відповідним чином обмежити його права чи закрити доступ до сторінки. При натисненні кнопки вихід - сессія видаляється:

	HttpSession s = request.getSession(false);
	if(s != null) s.invalidate();

До об’єктів сессії можна також просто доступатись з JSP сторінок, наприклад показати логін поточного користувача:

	${sessionScope.user.login}

Приклад обмеження доступу до URL за допомогою фільтру:

	WebFilter("/*")
	public class AuthorizatioFilter implements Filter {

	    public AuthorizatioFilter() {}

	    private final AuthRule[] rules = {
	    		new AuthRule("/admin.*", User.Permission.MANAGE_USERS),
	    		new AuthRule("/messages/?", User.Permission.USER),
	            new AuthRule("/avatars/?", User.Permission.USER),
	            new AuthRule("/moderator.*", User.Permission.MODERATE_POSTS)
	    }; 
	    
		public void init(FilterConfig fConfig) throws ServletException {}

		public void destroy() {}

		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
			HttpServletRequest httpReq = (HttpServletRequest) request; 
			int contextPathLen = httpReq.getContextPath().length();
			
			User.Permission requiredPerm = findRequredPermission(httpReq.getRequestURI().substring(contextPathLen));
			
			if(requiredPerm == null) {
				chain.doFilter(request, response);
				return;
			}

			HttpSession session = httpReq.getSession(false);
			
			if(session != null) {
				User user = (User) session.getAttribute(SessionConstants.USER);
				
				if(user != null && user.getPermissions().contains(requiredPerm)) {
					// we have been authenticated - pass the request 
					chain.doFilter(request, response);
					return;
				}
			}

			// 403 помилка - доступ заборонено
			// однак редірект на іншу сторінку з параметром теж підійшов би
			response.sendError(HttpServletResponse.SC_FORBIDDEN);  
		}
	
		private User.Permission findRequredPermission(String url) {
			for(AuthRule r: rules) {
				if(r.matchesUrl(url)) return r.getPermission();
			}
			
			return null;
		}	
	}

Права визначаються по URL і прописані в масиві `rules`. Для перевірки URL використовуються регулярні вирази `Pattern` - це спеціальна формальна мова для порівняння та пошуку та маніпуляцій зі стрічками. Не вдаючись в подробиці синтаксису: `.` у регулярних виразах означає будь-який символ, а `*` - що символу який йшов перед нею може повторюватись скільки завгодно разів, або ж не повторюватись зовсім, `?` означає що попереднього символу може не бути, або бути лише один раз (інші елементи синтаксису можна знайти в описі класу `Pattern` або на просторах інтернету), отже тепер можна розібрати як визначатимуться права на URL:

"/admin.*" - всі URL, що починаються на "/admin" потребують права:  User.Permission.MANAGE_USERS
"/messages/?" - URL виду "/messages/" або "/messages" потребують права User.Permission.USER   
і т. д.

Якщо користувач має відповідне право для доступу до URL викликається метод `chain.doFilter(request, response);` який каже що необхідно передати запит далі у наступний фільтр або ж сервлет, інакше відправляється 403 помилка (`SC_FORBIDDEN`) - яка означає що доступ до сторінки заборонено. Щоб не травмувати користувача голим повідомленням про помилку, додатково в файлі web.xml можливо вказати jsp або html сторінку, яка при цьому відображатиметься в браузері.

Клас `AuthRule` має вигляд:

	private static class AuthRule {
		private Pattern pattern;
		private User.Permission permission;
		
		public AuthRule(String urlPattern, User.Permission perm) {
			this.pattern = Pattern.compile(urlPattern);
			this.permission = perm;
		}
		
		boolean matchesUrl(String url) {
			return pattern.matcher(url).matches();
		}
		
		User.Permission getPermission() {
			return permission;
		}
	}

Співпадання URL шаблону (регулярному виразу) визначається методом `pattern.matcher(url).matches()`.

