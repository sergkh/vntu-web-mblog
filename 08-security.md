Методи ідентифікації користувача
------

Протокол HTTP побудований таким чином, що він не зберігає стану між запитами. Й це є як його перевагою (серверу не потрібно відслідковувати стан, тому він може потребувати менше ресурсів) так і недоліком, тому що залишається відкритою проблема ідентифікації користувача. Тобто потрібен механізм, який допоміг би зв’язати різні HTTP запити й сказати що вони відносяться до однієї сессії роботи користувача. Наприклад, в інтернет магазині потрібно знати що запит замовлення товару відправив той самий користувач, який 5 хвилин назад додав мікрохвильову піч у корзину, а не інший який просто натиснув кнопку замовлення. 

> Варіант просто завести відповідну змінну "корзина", наприклад, в сервісі чи контролері буде прекрасно працювати під час розробки - оскільки тільки ви, як розробник, будете замовляти товари. Однак як тільки користувачів стане більше, оскільки вони працюватимуть паралельно, можливі різні варіанти, коли один користувач буде замовляти товари іншого і перетирати чужі замовлення. Тому такий підхід краще відкинути одразу.

Перше, що спадає на думку - визначати користувача по IP адресі, однак відношення між користувачем та IP не є одним до одного - можливий варіант коли декілька користувачів (або навіть достатньо багато) може працювати під однією IP адресою - коли вони знаходяться за NAT, або ж навпаки один користувач може мати динамічну IP адресу, яка буде змінюватись під час перегляду сторінок сайту. Тому цей варіант не підходить. Однак можна виділити такі підходи:

1. Додавати параметр в кожен URL та в форми.
2. Додавати певний параметр до кожного HTTP пакету.

Перший варіант досить очевидний — при першому заході користувача, або ж після логіну додавати до всіх URL на сайті певний параметр — ідентифікатор сессії, який можна зв’язати з користувачем. При цьому ідентифікатор сессії має бути достатньо великим й випадковим, тому що, якщо взяти, наприклад, просто номер сессії підряд чи логін/ідентифікатор користувача:

	http://secure.somesite.com/userspage?sessionId=1567

зловмиснику досить просто буде підібрати ідентифікатор просто перебираючи номери чи логіни підряд, або ж хитріше - отримавши ідентифікатор своєї сессії додати чи відняти від нього 1 - отримаєш сессію попереднього або наступного користувача. Тому ідентифікатором сессії обирають достатньо довгий та випадковий набір символів, який не пов’язаний з користувачем:

	http://secure.somesite.com/userspage?sessionId=903hfw74n6lMsEfyodG8r

Однак варіант не дуже зручний як для користувача так і для розробників, оскільки потрібно не забути всюди додати параметр сессії в URL або ж як параметр форм. Також він має суттєвий недолік — ідентифікатор сессії користувача можна досить легко підглянути, а користувач може випадково передати доступ до свого акаунта випадково передавши URL на сайт комусь із знайомих.

Тому зазвичай для ідентифікації користувача використовуються другий варіант, який реалізується за допомогою *Cookies*, і тільки якщо вони вимкнені в браузері, іноді прибігають до першого варіанту.

Робота з *Cookies*
------

*Cookie* - це фрагмент даних, який встановлюється веб-сервером (зрідка на клієнтській стороні) і зберігається браузером на комп'ютері користувача. Браузер при доступі до сайту додає цей фрагмент даних до кожного HTTP пакету. При цьому особливістю *Cookie* є те, що вони передаються тільки при доступі до того домену, для якого вони були встановлені, тобто *Cookie* встановлена сайтом *facebook.com* буде передаватись тільки при доступі до сторінок цього сайту й ніякого іншого. 

*Cookie* дозволяють зберігати дані між запитами на стороні користувача, й на практиці зазвичай використовуються для:

1. Аутентифікації користувача;
2. Зберігання персональних переваг і налаштувань користувача;
3. Відстеження сеансу користувача;
4. Ведення статистики по користувачам.

Розповсюджений сценарій використання — створення *Cookie* з даними користувача та його сессії взаємодії з сайтом після логіну. Таким чином ідентифікація всіх наступних дій користувача за допомогою цієї *Cookie*. При натисненні кнопки "Вихід" або ж по проходженню певного періода чи закритті вікна браузера — *Cookie* знищується. Однак досить багато сайтів створюють *Cookie* одразу при заході на сайт й таким чином можуть запам’ятовувати налаштування користувача чи ідентифікувати його у майбутньому. 

Дані *Cookie* це параметр та його значення, й таких *Cookie* може бути скільки завгодно. Для того, щоб встановити *Cookie* сервер передає браузеру спеціальний заголовок HTTP пакету:

	Set-Cookie: name=value; expires=date; path=/; domain=.example.org.

Після чого браузер в кожному наступному запиті буде передавати отримані дані також у заголовку:

	Cookie: name=value

> Максимальний розмір *Cookie* — 4093 байти, однак враховуючи, що вона буде додаватись до кожного пакету необхідно намагатись мінімізувати розмір даних, що передаються у *Cookie* - оскільки це може значно збільшити трафік між клієнтом та сервером. 

Обов’язковими для *Cookie* є пара name=value, однак розглянемо інші можливі атрибути:

	Set-Cookie: lang=ua; expires=Fri, 31 Dec 2013 10:59:59 GMT; path=/; domain=.mydomain.net; Secure; HttpOnly; 

`Expires`
: вказує час, після якого *Cookie* буде автоматично видалено. Якщо цей атрибут не вказаний, то *Cookie* зберігається до закриття браузера.

`Max-Age`
: другий варіант вказання часу життя *Cookie* - час в секундах скільки буде дійсна *Cookie*.

`Domain`
: визначає домен, для якого *Cookie* є дійсним. Доступ до *Cookie* завжди обмежений доменом з якого він був встановлений, що є основою безпеки для *Cookie*, й якщо не вказати цього явно - буде використаний домен сайту який встановлював *Cookie*. Явно вказувати домен необхідно, якщо потрібно дозволити доступ до *Cookie* з піддоменів. Завжди починається з крапки.

`Path`
: визначає частину URL, для яких видима *Cookie*.

`Secure`
: наказує передавати *Cookie* тільки по безпечному з’єднанню, зазвичай https.

`HttpOnly`
: вказує, що значення *Cookie* неможливо отримати з javascript через об’єкт document.cookie. Дозволяє додатково захистити *Cookie* від крадіжки. 

`Version=1`
: - версія.

Щоб програмно записати *Cookie* необхідно додати параметр типу `HttpServletResponse` в контроллер:

```java
@RequestMapping("/cookie-set")
public String createCookie(HttpServletResponse response) {

	Cookie cookie = new Cookie("user", "login");
	cookie.setHttpOnly(true);
	cookie.setMaxAge(20*60); // 20 хвилин

    response.addCookie(new Cookie("foo", "bar"));
}
```

Прочитати дещо простіше:

```java
@RequestMapping("/cookie-read")
public String readCookie(@CookieValue(value = "user", defaultValue = "unknown") String loginCookieValue) {
 
    //..
}
```



Сессія користувача
------------

Сессії - це засіб, що суміщує в собі *Cookie* (параметри в URL, якщо *Cookie* заборонені) й зберігання даних на сервері для зберігання даних пов’язаних з сессією користувача.

Використання сесій в сервлетах досить проста і включає в себе отримання об’єкту сесії пов'язаної з поточним запитом, створення нового об'єкту сессії у разі потреби, зберігання та отримання інформації з сесії, та видалення сесій.

Для того щоб отримати, або створити сессію існує метод:

	HttpSession session = request.getSession(true);

В сессію можна занести будь-які дані:

	session.setAttribute("user", user);

а потім отримати їх:
	
	User user = (User) s.getAttribute("user");

При цьому дані зберігаються на сервері, а в *Cookie* передається тільки ідентифікатор сессії, що є довільною випадковою стрічкою достатньо довгою, щоб її було важко підібрати шляхом перебору.

Зазвичай логіка роботи з сессіями така: після логіну (іноді після реєстрації також) для користувача створюється сессія й в неї заносяться будь-які дані користувача необхідні для подальшої роботи, наприклад логін чи ідентифікатор користувача, можливі права доступу. Далі в усіх сторінках шляхом перевірки сессії можна визначити чи користувач є залогіненим й відповідним чином обмежити його права чи закрити доступ до сторінки. При натисненні кнопки вихід - сессія видаляється:

	HttpSession s = request.getSession(false);
	if(s != null) s.invalidate();

До об’єктів сессії можна також просто доступатись з JSP сторінок, наприклад показати логін поточного користувача:

	${sessionScope.user.login}

Приклад обмеження доступу до URL за допомогою фільтру:

	WebFilter("/*")
	public class AuthorizatioFilter implements Filter {

	    public AuthorizatioFilter() {}

	    private final AuthRule[] rules = {
	    		new AuthRule("/admin.*", User.Permission.MANAGE_USERS),
	    		new AuthRule("/messages/?", User.Permission.USER),
	            new AuthRule("/avatars/?", User.Permission.USER),
	            new AuthRule("/moderator.*", User.Permission.MODERATE_POSTS)
	    }; 
	    
		public void init(FilterConfig fConfig) throws ServletException {}

		public void destroy() {}

		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
			HttpServletRequest httpReq = (HttpServletRequest) request; 
			int contextPathLen = httpReq.getContextPath().length();
			
			User.Permission requiredPerm = findRequredPermission(httpReq.getRequestURI().substring(contextPathLen));
			
			if(requiredPerm == null) {
				chain.doFilter(request, response);
				return;
			}

			HttpSession session = httpReq.getSession(false);
			
			if(session != null) {
				User user = (User) session.getAttribute(SessionConstants.USER);
				
				if(user != null && user.getPermissions().contains(requiredPerm)) {
					// we have been authenticated - pass the request 
					chain.doFilter(request, response);
					return;
				}
			}

			// 403 помилка - доступ заборонено
			// однак редірект на іншу сторінку з параметром теж підійшов би
			response.sendError(HttpServletResponse.SC_FORBIDDEN);  
		}
	
		private User.Permission findRequredPermission(String url) {
			for(AuthRule r: rules) {
				if(r.matchesUrl(url)) return r.getPermission();
			}
			
			return null;
		}	
	}

Права визначаються по URL і прописані в масиві `rules`. Для перевірки URL використовуються регулярні вирази `Pattern` - це спеціальна формальна мова для порівняння та пошуку та маніпуляцій зі стрічками. Не вдаючись в подробиці синтаксису: `.` у регулярних виразах означає будь-який символ, а `*` - що символу який йшов перед нею може повторюватись скільки завгодно разів, або ж не повторюватись зовсім, `?` означає що попереднього символу може не бути, або бути лише один раз (інші елементи синтаксису можна знайти в описі класу `Pattern` або на просторах інтернету), отже тепер можна розібрати як визначатимуться права на URL:

"/admin.*" - всі URL, що починаються на "/admin" потребують права:  User.Permission.MANAGE_USERS
"/messages/?" - URL виду "/messages/" або "/messages" потребують права User.Permission.USER   
і т. д.

Якщо користувач має відповідне право для доступу до URL викликається метод `chain.doFilter(request, response);` який каже що необхідно передати запит далі у наступний фільтр або ж сервлет, інакше відправляється 403 помилка (`SC_FORBIDDEN`) - яка означає що доступ до сторінки заборонено. Щоб не травмувати користувача голим повідомленням про помилку, додатково в файлі web.xml можливо вказати jsp або html сторінку, яка при цьому відображатиметься в браузері.

Клас `AuthRule` має вигляд:

	private static class AuthRule {
		private Pattern pattern;
		private User.Permission permission;
		
		public AuthRule(String urlPattern, User.Permission perm) {
			this.pattern = Pattern.compile(urlPattern);
			this.permission = perm;
		}
		
		boolean matchesUrl(String url) {
			return pattern.matcher(url).matches();
		}
		
		User.Permission getPermission() {
			return permission;
		}
	}

Співпадання URL шаблону (регулярному виразу) визначається методом `pattern.matcher(url).matches()`.

